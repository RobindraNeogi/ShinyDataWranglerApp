{
    "collab_server" : "",
    "contents" : "#test new commit test test \nlibrary(shiny)\nlibrary(shinydashboard)\n## create dummy dataframe\n\n#ImportedData <- Dummydata<-data.frame(ID = c(\"LA1\",\"LA2\",\"LA3\",\"LA1\",\"LA2\",\"LA3\",\"LA1\",\"LA2\",\"LA3\"),\n#                          Level2 = c(\"A\",\"B\",\"C\",\"A\",\"B\",\"C\",\"A\",\"B\",\"C\"),\n#                        Level3 = c(\"AA\",\"BA\",\"CA\",\"BA\",\"BB\",\"BC\",\"CA\",\"CB\",\"CA\"),\n#                         Level4 = c(\"AAA\",\"BAB\",\"CAC\",\"ABA\",\"BBB\",\"CBC\",\"ACA\",\"BCB\",\"CCC\"),\n#                       Value = c(1,2,3,4,5,6,7,8,9))\n\n#ImportedData <-read.csv(\"C:\\\\Users\\\\neog968\\\\Desktop\\\\wgadata.csv\",header=TRUE)\nImportedData <-read.csv(\"/Users/datascience4/Documents/datatool/wgadata.csv\",header=TRUE)\nDefinitions <-read.csv(\"/Users/datascience4/Documents/datatool/wgadimensions.csv\",header=TRUE)\n\n\n\n\n## ContextualData is the data I want to join the aggregated subsets too. in the final one it would\n## have population, indicies of deprivation etc.\n\n#ContextualData <- data.frame(ID = c(\"LA1\",\"LA2\",\"LA3\"),\n#   Population = c(1,2,3),\n# deprivation=c(4,5,6))\n\n# ContextualData <-read.csv(\"C:\\\\Users\\\\neog968\\\\Desktop\\\\contextualdata.csv\",header=TRUE)\nContextualData <-read.csv(\"/Users/datascience4/Documents/datatool/contextualdata.csv\",header=TRUE)\n\n\nshinyServer(function(input, output, session) {\n  \n  ## Outputs filtered import data filtered by 4 menu selections\n  #output$ImportedDataFiltered <- renderTable({\n  # ImportedData<-ImportedData[ImportedData$Level1 %in% input$menu1,]\n  #ImportedData<-ImportedData[ImportedData$Level2 %in% input$menu2,]\n  #ImportedData<-ImportedData[ImportedData$Level3 %in% input$menu3,]\n  #ImportedData<-ImportedData[ImportedData$Level4 %in% input$menu4,]\n  #})\n  \n  \n  #display definitions table\n  output$ImportedDataFiltered2 <- DT::renderDataTable(\n    DT::datatable(Mergeddef$df, options = list(searching = FALSE),\n                  rownames= FALSE))\n  \n  \n  #display imported data table\n  output$ImportedDataFiltered <- DT::renderDataTable(\n    DT::datatable(FilteredImportData(), options = list(searching = FALSE),\n                  rownames= FALSE))\n  \n  \n  output$DownloadFilteredData <- downloadHandler(\n    filename = function() {\n      paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(FilteredImportData$df, file)\n    }\n  )\n  \n  ##  Imported data filtered by 4 menus (similar to above but wanted to reuse filtered data)\n  \n  FilteredImportData<-reactive({FilteredImportData <-ImportedData[ImportedData$Level1 %in% input$menu1,]\n  ImportedData<-ImportedData[ImportedData$Level2 %in% input$menu2,]\n  ImportedData<-ImportedData[ImportedData$Level3 %in% input$menu3,]\n  ImportedData<-ImportedData[ImportedData$Level4 %in% input$menu4,]\n  # ImportedData<-ImportedData[ImportedData$Level5 %in% input$menu5,]\n  })\n  \n  ## SubsetData This is aggregating the FilteredImportData, grouping by ID (in this case LA but in\n  ## final will be the LA/Year ID). Req input menus to get rid of temporary error message on launch\n  \n  SubsetData <-\n    \n    reactive({\n      req(input$menu1)\n      req(input$menu2)\n      req(input$menu3)\n      req(input$menu4)\n      #req(input$menu5)\n      \n      aggregate(Value ~ Code, FilteredImportData(), sum)\n    })\n  \n  \n  \n  SubsetDataDefinition <-\n    \n    reactive({\n      req(input$menu1)\n      req(input$menu2)\n      req(input$menu3)\n      req(input$menu4)\n      #req(input$menu5)\n      \n      unique(FilteredImportData()['ID'])\n    })\n  \n\n  \n  \n  ## This inputs aggreagte variable name from text input\n  namerev<-reactive({\n    as.character(paste(input$text))\n  })\n  \n  ## This replaces the column label 'Value' with the inputted name\n  SubsetDataDefinition2<-reactive({\n    d <- SubsetDataDefinition()\n    colnames(d)[colnames(d)=='ID'] <- namerev()\n    d\n  })\n  \n  ## This replaces the column label 'Value' with the inputted name\n  SubsetData2<-reactive({\n    d <- SubsetData()\n    colnames(d)[colnames(d)=='Value'] <- namerev()\n    d\n  })\n  \n  \n  ## This table displays the SubsetData\n  \n  output$SubsetData <- DT::renderDataTable(\n    DT::datatable(SubsetData(), options = list(searching = FALSE),\n                  rownames= FALSE))\n  \n  \n  ## When 'create aggregate' button clicked SubsetData is merged with ContextualData.\n  ## Each click adds new column\n  ## when 'create ratio' button is clicked a calculated column is created using the two selected columns and operator\n  \n  MergedContextualDataWithSubset <- reactiveValues()\n  MergedContextualDataWithSubset$df<-ContextualData\n  \n  \n  observe({\n    if(input$Merge > 0) {\n      isolate(\n        \n        MergedContextualDataWithSubset$df <- merge\n        (MergedContextualDataWithSubset$df,SubsetData2(),by=\"Code\",all=TRUE)\n      )\n    }\n  })\n  observe({\n    \n    if(input$button > 0) {\n      \n      isolate(if(input$operator==\"Divide by\") {\n        \n        newvar <- isolate((MergedContextualDataWithSubset$df[[input$xcol]] / MergedContextualDataWithSubset$df[[input$ycol]]))\n        isolate(MergedContextualDataWithSubset$df <- cbind(MergedContextualDataWithSubset$df, newvar))\n        isolate(colnames(MergedContextualDataWithSubset$df)[colnames(MergedContextualDataWithSubset$df)=='newvar'] <- as.character(paste(input$text2)))\n        \n        \n      })\n      \n      isolate(if(input$operator==\"Multiply\") {\n        \n        newvar <- isolate((MergedContextualDataWithSubset$df[[input$xcol]] * MergedContextualDataWithSubset$df[[input$ycol]]))\n        isolate(MergedContextualDataWithSubset$df <- cbind(MergedContextualDataWithSubset$df, newvar))\n        isolate(colnames(MergedContextualDataWithSubset$df)[colnames(MergedContextualDataWithSubset$df)=='newvar'] <- as.character(paste(input$text2)))\n        \n        \n      })\n      \n      isolate(if(input$operator==\"Add\") {\n        \n        newvar <- isolate((MergedContextualDataWithSubset$df[[input$xcol]] + MergedContextualDataWithSubset$df[[input$ycol]]))\n        isolate(MergedContextualDataWithSubset$df <- cbind(MergedContextualDataWithSubset$df, newvar))\n        isolate(colnames(MergedContextualDataWithSubset$df)[colnames(MergedContextualDataWithSubset$df)=='newvar'] <- as.character(paste(input$text2)))\n        \n        \n      })\n      \n      isolate(if(input$operator==\"Subtract\") {\n        \n        newvar <- isolate((MergedContextualDataWithSubset$df[[input$xcol]] - MergedContextualDataWithSubset$df[[input$ycol]]))\n        isolate(MergedContextualDataWithSubset$df <- cbind(MergedContextualDataWithSubset$df, newvar))\n        isolate(colnames(MergedContextualDataWithSubset$df)[colnames(MergedContextualDataWithSubset$df)=='newvar'] <- as.character(paste(input$text2)))\n        \n      })\n    }\n    \n  })\n  \n  \n  #merge filtered IDs to master ID file to be used later for definitions\n  \n  Mergeddef <- reactiveValues()\n  Mergeddef$df<-Definitions\n  \n  observe({\n    if(input$Merge > 0) {\n      isolate(\n        \n        Mergeddef$df <- merge\n        (Mergeddef$df,SubsetDataDefinition(),by=\"ID\",all=TRUE,type=\"full\")\n      )\n    }\n  })\n \n  \n  \n  \n  observe({\n    if(input$DeleteButton > 0) {\n      isolate(MergedContextualDataWithSubset$df <- MergedContextualDataWithSubset$df[-c(length( names( MergedContextualDataWithSubset$df ) ))]\n      )\n    }\n  })\n  \n  \n  ## Display MergedContextualDataWithSubset\n  output$MergedData <- DT::renderDataTable(\n    DT::datatable(MergedContextualDataWithSubset$df, options = list(searching = FALSE),\n                  rownames= FALSE))\n  \n  \n  #output$MergedData <- renderTable({MergedContextualDataWithSubset$df})\n  \n  \n  output$testdownload <- downloadHandler(\n    filename = function() {\n      paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(MergedContextualDataWithSubset$df, file)\n    }\n  )\n  \n  ## UI Elements\n  \n  ## Lists what has been entered in each menu\n  \n  output$FilterChoices <- renderText({\n    x <- input$menu1\n    y <- input$menu2\n    z <- input$menu3\n    zz<- input$menu4\n    zzz<- input$menu5\n    \n    ## This is left over from the code I borrowed online. It makes the word 'select' appear\n    ## if filters are empty, but my version has all valid options selected by default\n    \n    # if (any(\n    #  is.null(x),\n    # is.null(y),\n    #is.null(z),\n    #is.null(zz),\n    #is.null(zzz)\n    #  ))\n    #   return(\"Select\")\n    \n  })\n  \n  ## Makes 1st filter appear. options based on unique items in column\n  \n  output$control1 <- renderUI({\n    selectInput(\"menu1\", \"Select Level 1\", choices = unique(ImportedData$Level1),selected=\"Assets\",multiple=TRUE)\n  })\n  \n  ## Makes 2st filter appear. options based on filtering first column and bringing back options from option 2 column\n  \n  output$control2 <- renderUI({\n    x <- input$menu1\n    \n    choice2 <- ImportedData[ImportedData$Level1 %in% x,\n                            \"Level2\"]\n    selectInput(\"menu2\", \"Select Level 2\", choices = sort(unique(choice2)),selected=choice2, multiple=TRUE)\n  })\n  \n  ## 3rd filter options based on 1st and 2nd filters results\n  \n  output$control3 <- renderUI({\n    x <- input$menu1\n    y <- input$menu2\n    choice3 <- ImportedData[ImportedData$Level1 %in% x & ImportedData$Level2 %in% y,\n                            \"Level3\"]\n    \n    selectInput(\"menu3\", \"Select Level 3\", choices = sort(unique(choice3)),selected=choice3,multiple=TRUE)\n  })\n  \n  ## 4th filter based on first three\n  \n  output$control4 <- renderUI({\n    x <- input$menu1\n    y <- input$menu2\n    z <- input$menu3\n    choice4 <- ImportedData[ImportedData$Level1 %in% x & ImportedData$Level2 %in% y & ImportedData$Level3 %in% z,\n                            \"Level4\"]\n    \n    selectInput(\"menu4\", \"Select Level 4\", choices = sort(unique(choice4)),selected=choice4,multiple=TRUE)\n  })\n  \n  ## 5th filter based on first three\n  \n  #  output$control5 <- renderUI({\n  #   x <- input$menu1\n  #  y <- input$menu2\n  # z <- input$menu3\n  #zz <- input$menu4\n  #  if (any(\n  #   is.null(x),\n  #  is.null(y),\n  # is.null(z),\n  #is.null(zz)\n  #  ))\n  #   return(\"Select\")\n  \n  #  choice5 <- ImportedData[ImportedData$Level1 %in% x & ImportedData$Level2 %in% y & ImportedData$Level3 %in% z\n  #                         & ImportedData$Level4 %in% zz,\n  #                        \"Level5\"]\n  \n  #selectInput(\"menu5\", \"Menu5\", choices = choice5,selected=choice5,multiple=TRUE)\n  #})\n  \n  \n  ## creates a variable select of MergedContextualDataWithSubset\n  output$xcol <- renderUI({\n    \n    choicexcol <- names(MergedContextualDataWithSubset$df)[-(1:4)]\n    selectInput(\"xcol\", \"Metric part 1\", choices = choicexcol)\n  })\n  output$ycol <- renderUI({\n    \n    choiceycol <- names(MergedContextualDataWithSubset$df)[-(1:4)]\n    selectInput(\"ycol\", \"Metric part 2\", choices = choiceycol)\n    \n  })\n  output$Delete <- renderUI({\n    \n    Delete <- names(MergedContextualDataWithSubset$df)[-1]\n    selectInput(\"Delete\", \"Delete\", choices = Delete)\n    \n    \n  })\n  output$default <- renderText({ input$xcol;input$ycol })\n  \n})\n",
    "created" : 1492704709841.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3157472068",
    "id" : "62FB0287",
    "lastKnownWriteTime" : 1492705107,
    "last_content_update" : 1492705107,
    "path" : "~/Documents/ShinyApp/server.R",
    "project_path" : "server.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}